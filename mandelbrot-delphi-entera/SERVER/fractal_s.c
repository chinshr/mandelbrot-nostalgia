/*
 * Server Proxy Procededure Code for dce
 * for language C, version (1.0)
 * generated by Entera IDL version (1.0)
 * on Fri Sep 04 21:01:47 1998
 *
 * Interface:
 * name: fractal
 * uuid: 61a740ae-9699-11d1-aa8b-00c04fb17a3a version(1.1)
 *
 * Service Interface:
 * name: fractal
 * uuid: 61a740ae-9699-11d1-aa8b-00c04fb17a3a version(1.1)
 */

#ifndef _MACINTOSH_
#include <stdio.h>
#include <stdlib.h>
#else
#include "stdio.h"
#include "stdlib.h"
#endif
#include "ode.h"
#include "fractal_s.h"
#include "odestub.h"


rpc_if_handle_t ode_svr_ifspec_fractal_1_1 (error_status_t *odepStatus)
{
	return ((rpc_if_handle_t)ode_dstb_new_ifspec (
		4,               /* number of operations in the interface */
		1,               /* interface major version number */
		1,               /* interface minor version number */
		"61a740ae-9699-11d1-aa8b-00c04fb17a3a",            /* interface uuid */
		NULL,              /* server epv */
		NULL,              /* manager epv */
		odepStatus));
}


static void s_1_1_open (handle_t bh, ode_mar_p_t odepArgInfo, error_status_t* odeCommStatus, error_status_t* odeFaultStatus);
static void s_1_1_close (handle_t bh, ode_mar_p_t odepArgInfo, error_status_t* odeCommStatus, error_status_t* odeFaultStatus);
static void s_1_1_get_next (handle_t bh, ode_mar_p_t odepArgInfo, error_status_t* odeCommStatus, error_status_t* odeFaultStatus);
static void s_1_1_query_server (handle_t bh, ode_mar_p_t odepArgInfo, error_status_t* odeCommStatus, error_status_t* odeFaultStatus);

static ode_dstb_fn_p_t fractal_funcs[] = {
	s_1_1_open,
	s_1_1_close,
	s_1_1_get_next,
	s_1_1_query_server};

void rpc___dispatch_fractal_1_1
(
	unsigned32     aFuncNum,
	handle_t       odeBindingHandle,
	ode_mar_p_t    odepArgInfo,
	unsigned32*    odeCommStatus,
	unsigned32*    odeFaultStatus
)
{
	(*(fractal_funcs[aFuncNum]))
		(
			odeBindingHandle,
			odepArgInfo,
			odeCommStatus,
			odeFaultStatus
		);
}


void ode_dstb_register_fractal_1_1 (char* DedicatedArgs, error_status_t* odepStatus)
{
	ode_dstb_register_if
	(
		4,         /* Number of operations in Interface */
		1,         /* Major version number of Interface */
		1,         /* Minor version number of Interface */
		"61a740ae-9699-11d1-aa8b-00c04fb17a3a",      /* Interface UUID */
		NULL,        /* Object UUID */
		"fractal",      /* Interface Name */
		NULL,        /* Object UUID */
		1,         /* is service interface or is exported */
		rpc___dispatch_fractal_1_1,      /* interface RPC dispatcher */
		DedicatedArgs,
		0,
		"open,close,get_next,query_server",
		odepStatus
	);
}

static void s_1_1_open
(
	handle_t        odeBindingHandle,
	ode_mar_p_t     odepArgInfo,
	error_status_t* odeCommStatus,
	error_status_t* odeFaultStatus
)
{
/*  ODECOMMENT BEGIN DECLARATIONS fractal open */
	error_status_t  odeStatus = error_status_ok;
	error_status_t* odepStatus = &odeStatus;
	boolean32       odeUseSmAllocate = 1;
	boolean32       odeNewNode = 1;
	unsigned32 odeStubType = ode_c_stub_is_server;
	unsigned32 odePtrNumber = 0;
	boolean32 odeHasBeenMarshalled = 0;
	unsigned32 odeResult;
	client_data_t   cd;
	unsigned32 odeIdx_0, odeOffset_0, odeActualSize_0, odeMaxSize_0;
	unsigned32 odeIdx_1, odeOffset_1, odeActualSize_1, odeMaxSize_1;
	unsigned32 odeIdx_2, odeOffset_2, odeActualSize_2, odeMaxSize_2;
/*  ODECOMMENT END DECLARATIONS fractal open */

	odeIdx_0 = 0; odeOffset_0 = 0; odeActualSize_0 = 0; odeMaxSize_0 = 0;
	odeIdx_1 = 0; odeOffset_1 = 0; odeActualSize_1 = 0; odeMaxSize_1 = 0;
	odeIdx_2 = 0; odeOffset_2 = 0; odeActualSize_2 = 0; odeMaxSize_2 = 0;
#	if (!defined(ODE_VERSION)) || (ODE_VERSION < 33)
	ode_dstb_init_ptr_table (odeStubType, odepArgInfo, odepStatus);
#	endif

/*  ODECOMMENT BEGIN UNMARSHALLING fractal open */
	if (*odepStatus == error_status_ok)
	{
	ode_dstb_pop_align (odepArgInfo, 8, odepStatus);
	(cd.hostname) = (void*)ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.infrastructur) = (void*)ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.lan) = (void*)ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.width) = ode_dstb_pop_signed16 (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.height) = ode_dstb_pop_signed16 (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.iterations) = ode_dstb_pop_idl_byte (odeStubType, odepArgInfo, 0, odepStatus);
	ode_dstb_pop_align (odepArgInfo, 8, odepStatus);
	((cd.mndset).imag_min) = ode_dstb_pop_double (odeStubType, odepArgInfo, 0, odepStatus);
	((cd.mndset).imag_max) = ode_dstb_pop_double (odeStubType, odepArgInfo, 0, odepStatus);
	((cd.mndset).real_min) = ode_dstb_pop_double (odeStubType, odepArgInfo, 0, odepStatus);
	((cd.mndset).real_max) = ode_dstb_pop_double (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.rpc_requests) = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.bytes_received) = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.bytes_sent) = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	(cd.rpc_time) = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	odeHasBeenMarshalled = 0;
	odePtrNumber = (unsigned32)(cd.hostname);
	ode_dstb_inquire_ptr (odeStubType, odepArgInfo, odePtrNumber, (byte_p_t*)&(cd.hostname), &odeHasBeenMarshalled, odepStatus);
	if ((!odeHasBeenMarshalled) && (odePtrNumber))
	{
	odeMaxSize_0 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	if ((cd.hostname) == NULL)
	{
	ode_dstb_malloc (odeStubType, !odeUseSmAllocate, odeMaxSize_0 * sizeof(idl_char), &((cd.hostname)), odepStatus);
	}
	if ((cd.hostname))
	{
	ode_dstb_store_ptr (odeStubType, odepArgInfo, odePtrNumber, odeMaxSize_0 * sizeof(idl_char), (byte_p_t)(cd.hostname), &odeHasBeenMarshalled, odepStatus);
	odeOffset_0 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	odeActualSize_0 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	ode_dstb_pop_idl_char_array (odeStubType, odepArgInfo, 0, (idl_char*)&((cd.hostname)[odeOffset_0]), odeActualSize_0, odepStatus);
	}
	}
	odeHasBeenMarshalled = 0;
	odePtrNumber = (unsigned32)(cd.infrastructur);
	ode_dstb_inquire_ptr (odeStubType, odepArgInfo, odePtrNumber, (byte_p_t*)&(cd.infrastructur), &odeHasBeenMarshalled, odepStatus);
	if ((!odeHasBeenMarshalled) && (odePtrNumber))
	{
	odeMaxSize_1 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	if ((cd.infrastructur) == NULL)
	{
	ode_dstb_malloc (odeStubType, !odeUseSmAllocate, odeMaxSize_1 * sizeof(idl_char), &((cd.infrastructur)), odepStatus);
	}
	if ((cd.infrastructur))
	{
	ode_dstb_store_ptr (odeStubType, odepArgInfo, odePtrNumber, odeMaxSize_1 * sizeof(idl_char), (byte_p_t)(cd.infrastructur), &odeHasBeenMarshalled, odepStatus);
	odeOffset_1 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	odeActualSize_1 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	ode_dstb_pop_idl_char_array (odeStubType, odepArgInfo, 0, (idl_char*)&((cd.infrastructur)[odeOffset_1]), odeActualSize_1, odepStatus);
	}
	}
	odeHasBeenMarshalled = 0;
	odePtrNumber = (unsigned32)(cd.lan);
	ode_dstb_inquire_ptr (odeStubType, odepArgInfo, odePtrNumber, (byte_p_t*)&(cd.lan), &odeHasBeenMarshalled, odepStatus);
	if ((!odeHasBeenMarshalled) && (odePtrNumber))
	{
	odeMaxSize_2 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	if ((cd.lan) == NULL)
	{
	ode_dstb_malloc (odeStubType, !odeUseSmAllocate, odeMaxSize_2 * sizeof(idl_char), &((cd.lan)), odepStatus);
	}
	if ((cd.lan))
	{
	ode_dstb_store_ptr (odeStubType, odepArgInfo, odePtrNumber, odeMaxSize_2 * sizeof(idl_char), (byte_p_t)(cd.lan), &odeHasBeenMarshalled, odepStatus);
	odeOffset_2 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	odeActualSize_2 = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	ode_dstb_pop_idl_char_array (odeStubType, odepArgInfo, 0, (idl_char*)&((cd.lan)[odeOffset_2]), odeActualSize_2, odepStatus);
	}
	}
	}
/*  ODECOMMENT END UNMARSHALLING fractal open */
	if (*odepStatus == error_status_ok)
	{

/*  ODECOMMENT BEGIN CALL fractal open */
		odeResult = open (
			cd);

/*  ODECOMMENT END CALL fractal open */
	}
	ode_dstb_mar_reinit (odepArgInfo, odepStatus);

/*  ODECOMMENT BEGIN MARSHALLING fractal open */
	if (*odepStatus == error_status_ok)
	{
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeResult, odepStatus);
	}
/*  ODECOMMENT END MARSHALLING fractal open */
	if (*odeFaultStatus == error_status_ok)
	{		*odeFaultStatus = *odepStatus;
	}
	ode_mem_release();
}


static void s_1_1_close
(
	handle_t        odeBindingHandle,
	ode_mar_p_t     odepArgInfo,
	error_status_t* odeCommStatus,
	error_status_t* odeFaultStatus
)
{
/*  ODECOMMENT BEGIN DECLARATIONS fractal close */
	error_status_t  odeStatus = error_status_ok;
	error_status_t* odepStatus = &odeStatus;
	boolean32       odeUseSmAllocate = 1;
	boolean32       odeNewNode = 1;
	unsigned32 odeStubType = ode_c_stub_is_server;
	unsigned32 odePtrNumber = 0;
	boolean32 odeHasBeenMarshalled = 0;
	client_data_t odeResult;
	unsigned32   handle;
	unsigned32 odeIdx_0, odeOffset_0, odeActualSize_0, odeMaxSize_0;
	unsigned32 odeIdx_1, odeOffset_1, odeActualSize_1, odeMaxSize_1;
	unsigned32 odeIdx_2, odeOffset_2, odeActualSize_2, odeMaxSize_2;
/*  ODECOMMENT END DECLARATIONS fractal close */

	odeIdx_0 = 0; odeOffset_0 = 0; odeActualSize_0 = 0; odeMaxSize_0 = 0;
	odeIdx_1 = 0; odeOffset_1 = 0; odeActualSize_1 = 0; odeMaxSize_1 = 0;
	odeIdx_2 = 0; odeOffset_2 = 0; odeActualSize_2 = 0; odeMaxSize_2 = 0;
#	if (!defined(ODE_VERSION)) || (ODE_VERSION < 33)
	ode_dstb_init_ptr_table (odeStubType, odepArgInfo, odepStatus);
#	endif

/*  ODECOMMENT BEGIN UNMARSHALLING fractal close */
	if (*odepStatus == error_status_ok)
	{
	handle = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	}
/*  ODECOMMENT END UNMARSHALLING fractal close */
	if (*odepStatus == error_status_ok)
	{

/*  ODECOMMENT BEGIN CALL fractal close */
		odeResult = close (
			handle);

/*  ODECOMMENT END CALL fractal close */
	}
	ode_dstb_mar_reinit (odepArgInfo, odepStatus);

/*  ODECOMMENT BEGIN MARSHALLING fractal close */
	if (*odepStatus == error_status_ok)
	{
	ode_dstb_push_align (odepArgInfo, 8, odepStatus);
	odeHasBeenMarshalled = 0;
	odePtrNumber = ((odeResult.hostname) == NULL ? 0 : 1);
	ode_dstb_register_ptr (odeStubType, odepArgInfo, (byte_p_t)(odeResult.hostname), 0, &odePtrNumber, &odeHasBeenMarshalled, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odePtrNumber, odepStatus);
	odeHasBeenMarshalled = 0;
	odePtrNumber = ((odeResult.infrastructur) == NULL ? 0 : 1);
	ode_dstb_register_ptr (odeStubType, odepArgInfo, (byte_p_t)(odeResult.infrastructur), 0, &odePtrNumber, &odeHasBeenMarshalled, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odePtrNumber, odepStatus);
	odeHasBeenMarshalled = 0;
	odePtrNumber = ((odeResult.lan) == NULL ? 0 : 1);
	ode_dstb_register_ptr (odeStubType, odepArgInfo, (byte_p_t)(odeResult.lan), 0, &odePtrNumber, &odeHasBeenMarshalled, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odePtrNumber, odepStatus);
	ode_dstb_push_signed16 (odeStubType, odepArgInfo, 0, (odeResult.width), odepStatus);
	ode_dstb_push_signed16 (odeStubType, odepArgInfo, 0, (odeResult.height), odepStatus);
	ode_dstb_push_idl_byte (odeStubType, odepArgInfo, 0, (odeResult.iterations), odepStatus);
	ode_dstb_push_align (odepArgInfo, 8, odepStatus);
	ode_dstb_push_double (odeStubType, odepArgInfo, 0, ((odeResult.mndset).imag_min), odepStatus);
	ode_dstb_push_double (odeStubType, odepArgInfo, 0, ((odeResult.mndset).imag_max), odepStatus);
	ode_dstb_push_double (odeStubType, odepArgInfo, 0, ((odeResult.mndset).real_min), odepStatus);
	ode_dstb_push_double (odeStubType, odepArgInfo, 0, ((odeResult.mndset).real_max), odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, (odeResult.rpc_requests), odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, (odeResult.bytes_received), odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, (odeResult.bytes_sent), odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, (odeResult.rpc_time), odepStatus);
	odeOffset_0 = 0;
	odeMaxSize_0 = ode_dstb_strlen((void*)((odeResult.hostname)), 1);
	if (((odeResult.hostname)) && (odeMaxSize_0 < odeOffset_0)) ode_dstb_set_error (odepStatus, ode_s_invalid_argument);
	odeActualSize_0 = ode_dstb_strlen((void*)(odeResult.hostname), 1);
	odeHasBeenMarshalled = 0;
	odePtrNumber = ((odeResult.hostname) == NULL ? 0 : 1);
	ode_dstb_register_ptr (odeStubType, odepArgInfo, (byte_p_t)(odeResult.hostname), 1, &odePtrNumber, &odeHasBeenMarshalled, odepStatus);
	if ((!odeHasBeenMarshalled) && (odePtrNumber))
	{
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeMaxSize_0, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeOffset_0, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeActualSize_0, odepStatus);
	ode_dstb_push_idl_char_array (odeStubType, odepArgInfo, 0, (idl_char*)&((odeResult.hostname)[odeOffset_0]), odeActualSize_0, odepStatus);
	}
	odeOffset_1 = 0;
	odeMaxSize_1 = ode_dstb_strlen((void*)((odeResult.infrastructur)), 1);
	if (((odeResult.infrastructur)) && (odeMaxSize_1 < odeOffset_1)) ode_dstb_set_error (odepStatus, ode_s_invalid_argument);
	odeActualSize_1 = ode_dstb_strlen((void*)(odeResult.infrastructur), 1);
	odeHasBeenMarshalled = 0;
	odePtrNumber = ((odeResult.infrastructur) == NULL ? 0 : 1);
	ode_dstb_register_ptr (odeStubType, odepArgInfo, (byte_p_t)(odeResult.infrastructur), 1, &odePtrNumber, &odeHasBeenMarshalled, odepStatus);
	if ((!odeHasBeenMarshalled) && (odePtrNumber))
	{
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeMaxSize_1, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeOffset_1, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeActualSize_1, odepStatus);
	ode_dstb_push_idl_char_array (odeStubType, odepArgInfo, 0, (idl_char*)&((odeResult.infrastructur)[odeOffset_1]), odeActualSize_1, odepStatus);
	}
	odeOffset_2 = 0;
	odeMaxSize_2 = ode_dstb_strlen((void*)((odeResult.lan)), 1);
	if (((odeResult.lan)) && (odeMaxSize_2 < odeOffset_2)) ode_dstb_set_error (odepStatus, ode_s_invalid_argument);
	odeActualSize_2 = ode_dstb_strlen((void*)(odeResult.lan), 1);
	odeHasBeenMarshalled = 0;
	odePtrNumber = ((odeResult.lan) == NULL ? 0 : 1);
	ode_dstb_register_ptr (odeStubType, odepArgInfo, (byte_p_t)(odeResult.lan), 1, &odePtrNumber, &odeHasBeenMarshalled, odepStatus);
	if ((!odeHasBeenMarshalled) && (odePtrNumber))
	{
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeMaxSize_2, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeOffset_2, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeActualSize_2, odepStatus);
	ode_dstb_push_idl_char_array (odeStubType, odepArgInfo, 0, (idl_char*)&((odeResult.lan)[odeOffset_2]), odeActualSize_2, odepStatus);
	}
	}
/*  ODECOMMENT END MARSHALLING fractal close */
	if (*odeFaultStatus == error_status_ok)
	{		*odeFaultStatus = *odepStatus;
	}
	ode_mem_release();
}


static void s_1_1_get_next
(
	handle_t        odeBindingHandle,
	ode_mar_p_t     odepArgInfo,
	error_status_t* odeCommStatus,
	error_status_t* odeFaultStatus
)
{
/*  ODECOMMENT BEGIN DECLARATIONS fractal get_next */
	error_status_t  odeStatus = error_status_ok;
	error_status_t* odepStatus = &odeStatus;
	boolean32       odeUseSmAllocate = 1;
	boolean32       odeNewNode = 1;
	unsigned32 odeStubType = ode_c_stub_is_server;
	unsigned32 odePtrNumber = 0;
	boolean32 odeHasBeenMarshalled = 0;
	signed32 odeResult;
	unsigned32   handle;
	signed32   *outwidth;
	idl_byte**	row;
	unsigned32 odeIdx_0, odeOffset_0, odeActualSize_0, odeMaxSize_0;
/*  ODECOMMENT END DECLARATIONS fractal get_next */

	odeIdx_0 = 0; odeOffset_0 = 0; odeActualSize_0 = 0; odeMaxSize_0 = 0;
#	if (!defined(ODE_VERSION)) || (ODE_VERSION < 33)
	ode_dstb_init_ptr_table (odeStubType, odepArgInfo, odepStatus);
#	endif

/*  ODECOMMENT BEGIN UNMARSHALLING fractal get_next */
	if (*odepStatus == error_status_ok)
	{
	handle = ode_dstb_pop_unsigned32 (odeStubType, odepArgInfo, 0, odepStatus);
	}
/*  ODECOMMENT END UNMARSHALLING fractal get_next */
	if (*odepStatus == error_status_ok)
	{
	ode_dstb_malloc (odeStubType, odeUseSmAllocate, sizeof(signed32), &(outwidth), odepStatus);
	ode_dstb_malloc (odeStubType, odeUseSmAllocate, sizeof (void*), &(row), odepStatus);

/*  ODECOMMENT BEGIN CALL fractal get_next */
		odeResult = get_next (
			handle,
			outwidth,
			row);

/*  ODECOMMENT END CALL fractal get_next */
	}
	ode_dstb_mar_reinit (odepArgInfo, odepStatus);

/*  ODECOMMENT BEGIN MARSHALLING fractal get_next */
	if (*odepStatus == error_status_ok)
	{
	ode_dstb_push_signed32 (odeStubType, odepArgInfo, 0, (*outwidth), odepStatus);
	ode_dstb_push_idl_byte_Dstr (odeStubType, odepArgInfo, 0, *row, (unsigned32)*outwidth, odepStatus);
	ode_dstb_push_signed32 (odeStubType, odepArgInfo, 0, odeResult, odepStatus);
	}
/*  ODECOMMENT END MARSHALLING fractal get_next */
	if (*odeFaultStatus == error_status_ok)
	{		*odeFaultStatus = *odepStatus;
	}
	ode_mem_release();
}


static void s_1_1_query_server
(
	handle_t        odeBindingHandle,
	ode_mar_p_t     odepArgInfo,
	error_status_t* odeCommStatus,
	error_status_t* odeFaultStatus
)
{
/*  ODECOMMENT BEGIN DECLARATIONS fractal query_server */
	error_status_t  odeStatus = error_status_ok;
	error_status_t* odepStatus = &odeStatus;
	boolean32       odeUseSmAllocate = 1;
	boolean32       odeNewNode = 1;
	unsigned32 odeStubType = ode_c_stub_is_server;
	unsigned32 odePtrNumber = 0;
	boolean32 odeHasBeenMarshalled = 0;
	signed32 odeResult;
	server_data_t   *server_data;
	unsigned32 odeIdx_0, odeOffset_0, odeActualSize_0, odeMaxSize_0;
/*  ODECOMMENT END DECLARATIONS fractal query_server */

	odeIdx_0 = 0; odeOffset_0 = 0; odeActualSize_0 = 0; odeMaxSize_0 = 0;
#	if (!defined(ODE_VERSION)) || (ODE_VERSION < 33)
	ode_dstb_init_ptr_table (odeStubType, odepArgInfo, odepStatus);
#	endif

/*  ODECOMMENT BEGIN UNMARSHALLING fractal query_server */
	if (*odepStatus == error_status_ok)
	{
	}
/*  ODECOMMENT END UNMARSHALLING fractal query_server */
	if (*odepStatus == error_status_ok)
	{
	ode_dstb_malloc (odeStubType, odeUseSmAllocate, sizeof(server_data_t), &(server_data), odepStatus);

/*  ODECOMMENT BEGIN CALL fractal query_server */
		odeResult = query_server (
			server_data);

/*  ODECOMMENT END CALL fractal query_server */
	}
	ode_dstb_mar_reinit (odepArgInfo, odepStatus);

/*  ODECOMMENT BEGIN MARSHALLING fractal query_server */
	if (*odepStatus == error_status_ok)
	{
	ode_dstb_push_align (odepArgInfo, 4, odepStatus);
	odeHasBeenMarshalled = 0;
	odePtrNumber = (((*server_data).hostname) == NULL ? 0 : 1);
	ode_dstb_register_ptr (odeStubType, odepArgInfo, (byte_p_t)((*server_data).hostname), 0, &odePtrNumber, &odeHasBeenMarshalled, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odePtrNumber, odepStatus);
	ode_dstb_push_unsigned16 (odeStubType, odepArgInfo, 0, ((*server_data).handles), odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, ((*server_data).rpc_requests), odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, ((*server_data).bytes_received), odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, ((*server_data).bytes_sent), odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, ((*server_data).rpc_time), odepStatus);
	odeOffset_0 = 0;
	odeMaxSize_0 = ode_dstb_strlen((void*)(((*server_data).hostname)), 1);
	if ((((*server_data).hostname)) && (odeMaxSize_0 < odeOffset_0)) ode_dstb_set_error (odepStatus, ode_s_invalid_argument);
	odeActualSize_0 = ode_dstb_strlen((void*)((*server_data).hostname), 1);
	odeHasBeenMarshalled = 0;
	odePtrNumber = (((*server_data).hostname) == NULL ? 0 : 1);
	ode_dstb_register_ptr (odeStubType, odepArgInfo, (byte_p_t)((*server_data).hostname), 1, &odePtrNumber, &odeHasBeenMarshalled, odepStatus);
	if ((!odeHasBeenMarshalled) && (odePtrNumber))
	{
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeMaxSize_0, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeOffset_0, odepStatus);
	ode_dstb_push_unsigned32 (odeStubType, odepArgInfo, 0, odeActualSize_0, odepStatus);
	ode_dstb_push_idl_char_array (odeStubType, odepArgInfo, 0, (idl_char*)&(((*server_data).hostname)[odeOffset_0]), odeActualSize_0, odepStatus);
	}
	ode_dstb_push_signed32 (odeStubType, odepArgInfo, 0, odeResult, odepStatus);
	}
/*  ODECOMMENT END MARSHALLING fractal query_server */
	if (*odeFaultStatus == error_status_ok)
	{		*odeFaultStatus = *odepStatus;
	}
	ode_mem_release();
}


